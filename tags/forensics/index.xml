<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Forensics on Giulio &#39;peperunas&#39; De Pasquale</title>
    <link>https://blog.giugl.io/tags/forensics/</link>
    <description>Recent content in Forensics on Giulio &#39;peperunas&#39; De Pasquale</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Giulio De Pasquale</copyright>
    <lastBuildDate>Wed, 23 Sep 2015 16:56:59 +0200</lastBuildDate>
    <atom:link href="/tags/forensics/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>CSAW 2015 - Airport</title>
      <link>https://blog.giugl.io/post/csaw15-airport/</link>
      <pubDate>Wed, 23 Sep 2015 16:56:59 +0200</pubDate>
      
      <guid>https://blog.giugl.io/post/csaw15-airport/</guid>
      <description>&lt;p&gt;In this challenge we were provided with 5 images:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├── 1.png
├── 2.png
├── 3.png
├── 4.png
└── steghide.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The folder listing was a strong hint nevertheless: our objective was to extract something from &lt;code&gt;steghide.jpg&lt;/code&gt;  but first we had to get the proper passphrase for it.&lt;/p&gt;

&lt;h1 id=&#34;how&#34;&gt;How?&lt;/h1&gt;

&lt;p&gt;Each image shown a different airport: the first thing to do was recognizing each one. We mainly used &lt;a href=&#34;https://www.tineye.com/&#34; target=&#34;_blank&#34;&gt;TinEye&lt;/a&gt; and &lt;a href=&#34;https://www.imageraider.com/&#34; target=&#34;_blank&#34;&gt;Image Raider&lt;/a&gt;.
After uploading each image, we were able to name the first, second and fourth airport while the third one wasn&amp;rsquo;t found on those search engines.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.png -&amp;gt; Jose Marti
2.png -&amp;gt; Hong Kong
4.png -&amp;gt; Pearson
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get the third one, we searched the web for the main roads near the airport, in order to get some helpful information: this resulted in finding the airport name in just a few minutes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3.png -&amp;gt; Los Angeles
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;what-about-the-key&#34;&gt;What about the key?&lt;/h1&gt;

&lt;p&gt;Once we had pinned down each airport, it was trivial to think that the key would be the concatenation of each airport&amp;rsquo;s IATA code or name (following the image numbering).
The first try gave us the following string which we used as possible key for &lt;code&gt;steghide.jpg&lt;/code&gt;: &lt;code&gt;HAVHKGLAXYYZ&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;may-i-haz-flag&#34;&gt;May I haz flag?&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ &amp;gt; steghide extract -sf steghide.jpg
Enter passphrase:
wrote extracted data to &amp;quot;key.txt&amp;quot;.
$ &amp;gt; cat key.txt
iH4t3A1rp0rt5%
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Plaid CTF 2015 - PNG Uncorrupt</title>
      <link>https://blog.giugl.io/post/plaid15-png_uncorrupt/</link>
      <pubDate>Fri, 12 Jun 2015 16:57:09 +0200</pubDate>
      
      <guid>https://blog.giugl.io/post/plaid15-png_uncorrupt/</guid>
      <description>&lt;p&gt;Me and my team, &lt;a href=&#34;https://www.polictf.it&#34; target=&#34;_blank&#34;&gt;Tower of Hanoi&lt;/a&gt;, have played the PlaidCTF 2015: while my teammates did reversing stuff, my friend john and I did this awesome forensic challenge.&lt;/p&gt;

&lt;p&gt;This was the challenge description:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We received this PNG file, but we&amp;rsquo;re a bit concerned the transmission may have not quite been perfect.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It was easy to understand we had to repair a PNG file, but first, we checked what we had in our hands. So, we ran &lt;code&gt;file&lt;/code&gt; on the challenge file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;corrupt_735acee15fa4f3be8ecd0c6bcf294fd4.png: data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The file was, in fact, corrupted since it wasn&amp;rsquo;t recognized as a PNG image. The next step was to recreate the correct PNG header in our file, which should have been
&lt;code&gt;0x89 0x50 0x4E 0x47 0xD 0xA 0x1A 0xA&lt;/code&gt; instead of &lt;code&gt;0x89 0x50 0x4E 0x47 0x0A 0x1A 0x0A&lt;/code&gt;, the actual header of our challenge&amp;rsquo;s file.&lt;/p&gt;

&lt;p&gt;With the help of a hex editor we added the missing &lt;code&gt;0x0D&lt;/code&gt; byte, renamed the file and&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;solution.png: PNG image data, 960 x 600, 8-bit/color RGB, non-interlaced
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bad news ahead: by opening the image we were greeted by a fantastic &lt;em&gt;960x600&lt;/em&gt; black image. Not bad. Some of the PNG &lt;em&gt;chunks&lt;/em&gt; must have been corrupted as well then.&lt;/p&gt;

&lt;p&gt;Before going further with the challenge details, I&amp;rsquo;d like to &lt;em&gt;quickly&lt;/em&gt; summarize how a PNG file actually is.&lt;/p&gt;

&lt;p&gt;A PNG image has a lot of blocks, called &lt;em&gt;chunks&lt;/em&gt;, which have the same structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|&amp;lt;- 4 bytes -&amp;gt;| |&amp;lt;- 4 bytes -&amp;gt;| |&amp;lt;- variable -&amp;gt;| |&amp;lt;- 4 bytes  -&amp;gt;|
|&amp;lt;- LENGTH  -&amp;gt;| |&amp;lt;-   NAME  -&amp;gt;| |&amp;lt;-   DATA   -&amp;gt;| |&amp;lt;- CHECKSUM -&amp;gt;|
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The most important one, which actually represents the image, is called &lt;strong&gt;IDAT&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Now: we made a strong assumption.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Every chunks&amp;rsquo; checksum and length section weren&amp;rsquo;t altered at all&lt;/strong&gt; (in this way we could understand what was the original content of the data block in each chunk)&lt;/p&gt;

&lt;p&gt;With the aforementioned assumption in our mind, we checked if any chunk had an unexpected checksum: &lt;code&gt;pngcheck&lt;/code&gt; helped us doing this.&lt;/p&gt;

&lt;p&gt;There were several corrupted &lt;strong&gt;IDAT&lt;/strong&gt; chunks so we wrote a script to bruteforce the missing bytes of each chunk.&lt;/p&gt;

&lt;p&gt;What we thought was: the &lt;strong&gt;LENGTH&lt;/strong&gt; section indicates how many bytes &lt;em&gt;should have&lt;/em&gt; been in the chunk in the first place so we compared that value with the &lt;em&gt;actual&lt;/em&gt; length of the corrupted image &lt;strong&gt;DATA&lt;/strong&gt; section.&lt;/p&gt;

&lt;p&gt;We wrote the script and&amp;hellip; it took a lifetime. No results. Much joy.&lt;/p&gt;

&lt;p&gt;When our hope was gone and our PCs were slowly turning in frying pans, &lt;a href=&#34;https://github.com/esseks&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;esseks&lt;/strong&gt;&lt;/a&gt; another awesome teammate, came to the rescue.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Guys, text conversion.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Which meant: &lt;em&gt;why would you bruteforce everything?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;When an image is downloaded as &lt;em&gt;text&lt;/em&gt; through FTP (ASCII Mode), each &lt;code&gt;0x0D 0x0A&lt;/code&gt; bytes tuple (&lt;code&gt;\r\n&lt;/code&gt;) is truncated to &lt;code&gt;0x0A&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Long story short, here&amp;rsquo;s what we did next:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Edited the script making it output the offset in the file where the &lt;code&gt;0x0D&lt;/code&gt; byte should have been appended&lt;/li&gt;
&lt;li&gt;Waited for the script to do its magic&lt;/li&gt;
&lt;li&gt;Edited by hand the PNG image &lt;em&gt;(sad but true)&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Did we succeed?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.giugl.io/img/pngcorrupt.png&#34; alt=&#34;Final Solution&#34; /&gt;&lt;/p&gt;

&lt;p&gt;PS: I know that some of you was wondering how wonderful our script was&amp;hellip;so&amp;hellip; have a good headache after it ;-)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import mmap
import struct
from zlib import crc32
import re
import sys
try:
    def strtobytes(x): return bytes(x)
    def bytestostr(x): return str(x)
except (NameError, TypeError):
    strtobytes = str
    bytestostr = str

class IDATChunk:
    counter = &amp;quot;&amp;quot;
    length = &amp;quot;&amp;quot;
    data = &amp;quot;&amp;quot;
    checksum = &amp;quot;&amp;quot;
    def __init__(self, counter, length, data, checksum):
        self.counter = counter
        self.length = int(length.encode(&amp;quot;hex&amp;quot;), 16)
        self.data = data
        self.checksum = checksum

def verifyChecksum(data, checksum):
    verify = crc32(strtobytes(&amp;quot;IDAT&amp;quot;))
    verify = crc32(data, verify)
    verify &amp;amp;= 2**32 - 1
    verify = struct.pack(&#39;!I&#39;, verify)
    if verify != checksum:
        return False
    return True


def print_bar(perc=.0):
    SIZE = 20
    return &amp;quot;[%s%s] %f\r&amp;quot; % (&amp;quot;#&amp;quot; * int(20*perc), &amp;quot; &amp;quot; * (20 - int(20*perc)), perc)


def addNewByte(data, seek = &amp;quot;\n&amp;quot;, debug=False, byte_to_insert = &amp;quot;\r&amp;quot;):
    if debug:
        print &amp;quot;DEBUG!!!&amp;quot;, type(data), data
    indexes = [m.start() for m in re.finditer(seek, data)]
    for i in indexes:
        if byte_to_insert is None:
            for byte_to_insert in range(255):
                new_data = data[:i]+ chr(byte_to_insert) + data[i:]
                yield str(new_data), i, byte_to_insert, len(indexes)
        else:
            new_data = data[:i]+ byte_to_insert + data[i:]
            yield str(new_data), i, byte_to_insert, len(indexes)



def getCorrectData(idatobj):
    if idatobj.length - len(idatobj.data) == 1 :
        for new_data, i, byte_to_insert, num in addNewByte(idatobj.data):
            if verifyChecksum(new_data, idatobj.checksum):
                print &amp;quot;Offset byte: &amp;quot;, str(i), repr(byte_to_insert)
                return new_data

    elif idatobj.length - len(idatobj.data) == 2 :
        counter = 0
        for data_plus_1, i1, byte_1, num in addNewByte(idatobj.data):
            for data_plus_2, i2, byte_2, num2 in addNewByte(data_plus_1):
                sys.stderr.write(print_bar(float(counter)/255/255/num))
                counter += 1
                if verifyChecksum(data_plus_2, idatobj.checksum):
                    print &amp;quot;Offset byte 1: &amp;quot;, str(i1), &amp;quot; Byte: &amp;quot;, repr(byte_1)
                    print &amp;quot;Offset byte 2: &amp;quot;, str(i2), &amp;quot; Byte: &amp;quot;, repr(byte_2)
                    return data_plus_2
    elif idatobj.length - len(idatobj.data) == 3 :
        counter = 0
        for data_plus_1, i1, byte_1, num in addNewByte(idatobj.data):
            for data_plus_2, i2, byte_2, num in addNewByte(data_plus_1):
                for data_plus_3, i3, byte_3, num in addNewByte(data_plus_2):
                    sys.stderr.write(print_bar(float(counter)/255/255/255))
                    counter += 1
                    if verifyChecksum(data_plus_3, idatobj.checksum):
                        print &amp;quot;Offset byte 1: &amp;quot;, str(i1), &amp;quot; Byte: &amp;quot;, repr(byte_1)
                        print &amp;quot;Offset byte 2: &amp;quot;, str(i2), &amp;quot; Byte: &amp;quot;, repr(byte_2)
                        print &amp;quot;Offset byte 3: &amp;quot;, str(i3), &amp;quot; Byte: &amp;quot;, repr(byte_3)
                        return data_plus_3
def getlen(mm, idatindex):
    return int(&amp;quot;0x&amp;quot; + mm[idatindex-4:idatindex].encode(&amp;quot;hex&amp;quot;), 0)

idat_chunks = []

f = open(&#39;/home/giulio/CTF/Plaid5/forensics/original.png&#39;, &amp;quot;r+b&amp;quot;)
mm = mmap.mmap(f.fileno(), 0)
#
# L | IDAT | DATA | CHECKSUM ---&amp;gt; {L} {DATA, CHECKSUM, L} {DATA, CHECKSUM, L} ... {DATA, CHECKSUM}
#
shitgotreal = mm.read(mm.size()).split(&amp;quot;Adobe Fireworks CS6&amp;quot;)[1][4:].split(&amp;quot;IEND&amp;quot;)[0].split(&amp;quot;IDAT&amp;quot;)

for cont, idat in [ (x,shitgotreal[x])  for x in range(1, len(shitgotreal))]:
    length = shitgotreal[cont-1][-4:]
    data = idat[:-8]
    checksum = idat[-8:-4]
    idat_chunks.append(IDATChunk(cont,length, data, checksum))
for x in idat_chunks:
    print &amp;quot;IDAT &amp;quot; + str(x.counter) + &amp;quot;: ...&amp;quot;
    getCorrectData(x)
    print &amp;quot;|------|&amp;quot;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>
